<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Alex Hopkins</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<link rel="icon" href="/favicon.ico?v=2" type="image/x-icon" />
		<style>

		</style>
	</head>
	<body>

		<h1 id="name" style="left: 30px"><a style="text-decoration: none; color: aliceblue;" href="https://www.linkedin.com/in/ahop/">ALEX HOPKINS</a></h1>

		<h1 id="tabs" style="right: 30px"><span style="color: rgb(115, 255, 255);">DESIGN</span> - <span style="color: rgb(191, 142, 255);">DEVELOPMENT</span></h1>

		<div id="info">
			<h1 id="closer">X</h1>
			<h1 id="title">Hi</h1>
			<p id="desc">I'm an emerging visual creative with a background in maths and code, based in Bristol</p>
			<img id="pic" src="pics/help.png">
			<h2 id="roles">Click on the small orbs to check out my projects, the purple ones are design projects (user experience, graphics, etc) and the green are development projects (frontend, javascript games, etc)</h2>
			<h2 id="client">Want to collaborate? <a href="https://www.linkedin.com/in/ahop/">Find me here</a> Or <a href="alexrehopkins@gmail.com">contact me</a></h2>
		</div>

		<div id="container"></div>

		<script type="module">

			import * as THREE from '/three.module.js';
			import { OrbitControls } from '/OrbitControls.js';
			import { EffectComposer } from '/EffectComposer.js';
			import { RenderPass } from '/RenderPass.js';
			import { UnrealBloomPass } from '/UnrealBloomPass.js';
			

			const colorScheme = {
				standingOrbDev: 0x3a32ac,
				hoverOrbDes: 0x69d9ef,
				clickedOrb: 0xffffff,
				standingOrbDes: 0x328eac,
				hoverOrbDev: 0x696bef,
				background: 0x04060b, //141a30
				sunOrb: 0x69d9ef
			};

			const variables = {
				rotSpeed: 0.3,
				sunBeamSpeed: 1,
				particleSpeed: 1/8,
				sunbeamCount: 3
			}

			let camera, stats;
			let composer, renderer, clock;

			let controls;
			let mouse, raycaster;
			let originalText, originalTitle, originalDesc, originalImg, originalRoles, originalClient;

			let currentSelected = -1;

			let mode = 1;

			let data;

			let timer;

			let particleGeo, vertices, sprite, particles, particleMat;
			let scene;

			//new objects
			let grid;
			let tracker = 0;

			let torusArray = [];


			const params = {
				exposure: 1,
				bloomStrength: 1,
				bloomThreshold: 0,
				bloomRadius: 0
			};

			init();

			function close() {
				document.getElementById("info").style.display = "none";
			}

			function init() {
				originalText = document.getElementById( 'tabs' ).innerHTML;
				originalTitle = document.getElementById( 'title' ).innerHTML;
				originalClient = document.getElementById( 'client' ).innerHTML;
				originalDesc = document.getElementById( 'desc' ).innerHTML;
				originalImg = document.getElementById( 'pic' ).src;
				originalRoles = document.getElementById( 'roles' ).innerHTML;
				//import project data
				fetch("/Projects.json")
				.then(response => {
				return response.json();
				})
				.then(database => {
					data = database;
					console.log(data);
					animate();
				});

				const container = document.getElementById( 'container' );

				clock = new THREE.Clock();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ReinhardToneMapping;
				container.appendChild( renderer.domElement );
				
				scene = new THREE.Scene();

				//particles

				particleGeo = new THREE.BufferGeometry();
				vertices = [];
				sprite = new THREE.TextureLoader().load('pics/sprite.png');


				for ( let i = 0; i < 2000; i ++ ) {
					const x = 40 * (Math.random() - 0.5);
					const y = 40 * (Math.random() - 0.5);
					const z = 40 *(Math.random() - 0.5);

					vertices.push( x, y, z );
				}
				particleGeo.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
				particleMat = new THREE.PointsMaterial( { size: 0.2, sizeAttenuation: true, map: sprite, alphaTest: 0.5, transparent: true } );
				particleMat.color.setHSL( 1.0, 0.3, 0.7 );
				particles = new THREE.Points( particleGeo, particleMat );
				scene.add(particles);
				scene.background = new THREE.Color( colorScheme.background );
				
				
				
				//camera

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.set( 0, 14, 0 );
				scene.add( camera );
				scene.fog = new THREE.Fog(0x04060b, 10, 45);

				controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.5;
				controls.minDistance = 4;
				controls.maxDistance = 24;
				controls.enablePan = false;
				scene.add( new THREE.AmbientLight( 0x404040 ,1 ) );
				const pointLight = new THREE.PointLight( 0xffffff, 1 );
				camera.add( pointLight );
				const renderScene = new RenderPass( scene, camera );
				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;
				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );
				

				//objects
				/*
				let material = new THREE.LineBasicMaterial( { color: 0xc430ff } );
				const points = [];
				
				for (let i = 1; i < 100; i++) {
					points.push( new THREE.Vector3( i-50, 0, -50 ) );
					points.push( new THREE.Vector3( i-50, 0, 50 ) );
					points.push( new THREE.Vector3( i+1-50, 0, 50 ) );
				}
				points.push( new THREE.Vector3( 50, 0, -50) );
				for (let i = 1; i < 100; i++) {
					points.push( new THREE.Vector3( -50, 0, i-50) );
					points.push( new THREE.Vector3( 50, 0, i-50) );
					points.push( new THREE.Vector3( 50, 0, i+1-50) );
				}
				let geometry = new THREE.BufferGeometry().setFromPoints( points );
				grid = new THREE.Line( geometry, material );
				scene.add(grid);
				*/
				for (let i = 0; i < 50; i++) {
					torusMaker(Math.random()*20-10,Math.random()/15,Math.random()*10, i)
				}

				//sun

				//event
				window.addEventListener( 'resize', onWindowResize );
			}


			function torusMaker(position, size, radius, which) {
				let material = new THREE.MeshBasicMaterial( { color: 0xffffff } );
				let geometry = new THREE.TorusGeometry( radius, size, 16, 100, Math.random()*7 );
				let torus = new THREE.Mesh( geometry, material );
				torus.rotateZ(6*Math.random());
				torus.position.set(0,0,position);
				torus.speed = radius;
				torusArray[which] = (torus);
				scene.add( torusArray[which] );
			}


			function onWindowResize() {
				const width = window.innerWidth;
				const height = window.innerHeight;
				camera.aspect = width / height;
				camera.updateProjectionMatrix();
				renderer.setSize( width, height );
				composer.setSize( width, height );
			}

			function animate() {
				const delta = clock.getDelta();
				tracker += 2;
				if (tracker > 100) {
					tracker = 0;
				}
				particles.rotateZ(delta/5);
				for (let i = 0; i < torusArray.length; i++) {
					torusArray[i].rotateZ(delta/torusArray[i].speed);
				}
				requestAnimationFrame( animate );
				controls.update();
				composer.render();
			}


			function updateInfo(project,topic) {
				document.getElementById("info").style.display = "block";
				if (topic == "design") {
					document.getElementById("title").innerHTML = data.design[project].title;
					document.getElementById("desc").innerHTML = data.design[project].description;
					document.getElementById("client").innerHTML = data.design[project].client;
					document.getElementById("roles").innerHTML = data.design[project].role;
				}
				else if (topic == "development") {
					document.getElementById("title").innerHTML = data.development[project-data.design.length].title;
					document.getElementById("desc").innerHTML = data.development[project-data.design.length].description;
					document.getElementById("client").innerHTML = data.development[project-data.design.length].client;
					document.getElementById("roles").innerHTML = data.development[project-data.design.length].role;
				}
				

			}
			/*
			function satellite(value,topic) { //width, thickness
				let width;
				let thickness;
				let torusMat;
				let orbMat;
				let colorer;
				let hoverCol;
				let overallValue;
				let title;
				if (topic == "design") {
					width = data.design[value].radius;
					thickness = data.design[value].importance;
					colorer = colorScheme.standingOrbDes;
					hoverCol = colorScheme.hoverOrbDes;
					overallValue = value;
					title = data.design[value].title;
				}
				else if (topic == "development") {
					width = data.development[value].radius;
					thickness = data.development[value].importance;
					colorer = colorScheme.standingOrbDev;
					hoverCol = colorScheme.hoverOrbDev;
					overallValue = value+data.design.length;
					title = data.development[value].title;
				}
				torusMat = new THREE.MeshBasicMaterial( { color: colorer, transparent: true, opacity: 0.2});
				orbMat = new THREE.MeshBasicMaterial( { color: colorer });
				const torusSpawn = new THREE.Mesh(new THREE.TorusGeometry(width,thickness/20,25,40),torusMat );
				torusSpawn.rotateX(Math.PI/2);
				const orbitSpawn = new THREE.Mesh(new THREE.SphereGeometry(thickness,32,32), orbMat);
				orbitSpawn.position.set(width,0,0);
				orbitSpawn.layers.enable( 1 );
				orbitSpawn.val = overallValue;
				orbitSpawn.title = title;
				orbitSpawn.hoverColor = hoverCol;
				orbitSpawn.topic = topic;
				orbitArray.push(orbitSpawn);
				const group = new THREE.Group();
				group.rotateY(Math.random()*6);
				group.rotateX(Math.random()/2);
				group.add( torusSpawn );
				group.add( orbitSpawn );
				group.width = width;
				group.originalColor = colorer;
				group.layers.enable( 1 );
				satArray.push(group);
				scene.add( group );				
			}
			*/
			document.getElementById("closer").addEventListener("click", close);
		</script>
	</body>
</html>
