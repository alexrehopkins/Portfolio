<!DOCTYPE html>
<html lang="en">
	<head>
		<title>Alex Hopkins</title>
		<meta charset="utf-8">
		<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
		<link type="text/css" rel="stylesheet" href="main.css">
		<style>

		</style>
	</head>
	<body>

		<h1 id="name">ALEX HOPKINS</h1>

		<div id="container"></div>

		<script type="module">

			import * as THREE from '/three.module.js';
			import { OrbitControls } from '/OrbitControls.js';
			import { EffectComposer } from '/EffectComposer.js';
			import { RenderPass } from '/RenderPass.js';
			import { UnrealBloomPass } from '/UnrealBloomPass.js';

			let camera, stats;
			let composer, renderer, mixer, clock;

			let geometry, material, line, wireframe;

			let torusGeo, torus2;

			let timer;

			let satArray = [];
			let orbitArray = [];

			let values = [
				{
					width: 2.5
				},
				{
					width: 3
				},
				{
					width: 4
				},
				{
					width: 5
				}
			];

			let particleGeo, vertices, sprite, particles, particleMat;
			let scene;

			const params = {
				exposure: 1,
				bloomStrength: 1,
				bloomThreshold: 0,
				bloomRadius: 0
			};

			init();

			function init() {

				const container = document.getElementById( 'container' );

				clock = new THREE.Clock();

				renderer = new THREE.WebGLRenderer( { antialias: true } );
				renderer.setPixelRatio( window.devicePixelRatio );
				renderer.setSize( window.innerWidth, window.innerHeight );
				renderer.toneMapping = THREE.ReinhardToneMapping;
				container.appendChild( renderer.domElement );

				scene = new THREE.Scene();

				//particles

				particleGeo = new THREE.BufferGeometry();
				vertices = [];
				sprite = new THREE.TextureLoader().load('sprite.png');


				for ( let i = 0; i < 1000; i ++ ) {
					const x = 40 * (Math.random() - 0.5);
					const y = 40 * (Math.random() - 0.5);
					const z = 40 *(Math.random() - 0.5);

					vertices.push( x, y, z );
				}
				particleGeo.setAttribute( 'position', new THREE.Float32BufferAttribute( vertices, 3 ) );
				particleMat = new THREE.PointsMaterial( { size: 0.2, sizeAttenuation: true, map: sprite, alphaTest: 0.5, transparent: true } );
				particleMat.color.setHSL( 1.0, 0.3, 0.7 );
				particles = new THREE.Points( particleGeo, particleMat );
				scene.add(particles);

				//camera

				camera = new THREE.PerspectiveCamera( 40, window.innerWidth / window.innerHeight, 0.01, 100 );
				camera.position.set( 0, 14, 0 );
				scene.add( camera );
				scene.fog = new THREE.Fog(0x00ffff, 0.1, 20);

				const controls = new OrbitControls( camera, renderer.domElement );
				controls.maxPolarAngle = Math.PI * 0.5;
				controls.minDistance = 4;
				controls.maxDistance = 14;
				controls.autoRotate = true;

				scene.add( new THREE.AmbientLight( 0x404040 ) );

				const pointLight = new THREE.PointLight( 0xffffff, 1 );
				camera.add( pointLight );

				const renderScene = new RenderPass( scene, camera );

				const bloomPass = new UnrealBloomPass( new THREE.Vector2( window.innerWidth, window.innerHeight ), 1.5, 0.4, 0.85 );
				bloomPass.threshold = params.bloomThreshold;
				bloomPass.strength = params.bloomStrength;
				bloomPass.radius = params.bloomRadius;

				composer = new EffectComposer( renderer );
				composer.addPass( renderScene );
				composer.addPass( bloomPass );

				//geometry = new THREE.TorusKnotGeometry(2,0.01,500,20,10,17); //radius, tube, tubsection, radsection, p, q
				//material = new THREE.MeshBasicMaterial( { color: 0xff00ff } );
				//line = new THREE.Mesh( geometry, material );
				//scene.add( line );
				//line.rotateX(Math.PI/2);
				
				//torusGeo = new THREE.Mesh(new THREE.TorusGeometry(2,0.99,25,40),new THREE.MeshBasicMaterial( { color: 0xff00ff, transparent: true, opacity: 0.05 } ));
				//scene.add( torusGeo );
				//torusGeo.rotateX(Math.PI/2);

				const orbitSpawn = new THREE.Mesh(new THREE.SphereGeometry(1,32,32),new THREE.MeshBasicMaterial( { color: 0xff00ff } ));
				scene.add(orbitSpawn);
				for (let i = 0; i < values.length; i++) {
					satellite(values[i].width,0.01);//width,thickness
				}


				animate();
				window.addEventListener( 'resize', onWindowResize );

			}

			function onWindowResize() {

				const width = window.innerWidth;
				const height = window.innerHeight;

				camera.aspect = width / height;
				camera.updateProjectionMatrix();

				renderer.setSize( width, height );
				composer.setSize( width, height );

			}

			function animate() {

				requestAnimationFrame( animate );

				const delta = clock.getDelta();

				//line.rotateY(delta/4);
				//torusGeo.rotateY(delta/4);


				
				for (let i = 0; i < orbitArray.length; i++) {
					orbitArray[i].rotateY(-delta);
					orbitArray[i].position.z = values[i].width*Math.sin(clock.getElapsedTime ()/values[i].width );
					orbitArray[i].position.x = values[i].width*Math.cos(clock.getElapsedTime ()/values[i].width );
				}
				
				
				//console.log(Math.PI/2+torus2.rotation.y);
				

				particles.rotateY(delta/8);
				particles.rotateX(delta/32);

				composer.render();

			}

			function satellite(width,thickness) { //width, thickness
				const torusSpawn = new THREE.Mesh(new THREE.TorusGeometry(width,thickness,25,40),new THREE.MeshBasicMaterial( { color: 0xff00ff, transparent: true, opacity: 0.1} ));
				torusSpawn.rotateX(Math.PI/2);
				satArray.push(torusSpawn);
				scene.add( torusSpawn );
				const orbitSpawn = new THREE.Mesh(new THREE.SphereGeometry(0.1),new THREE.MeshBasicMaterial( { color: 0xff00ff } ));
				orbitArray.push(orbitSpawn);
				scene.add( orbitSpawn );
				
			}

		</script>

	</body>

</html>
